function [ ] = RLDraft1( )
clearvars
close all

% Provides wind energy as a function of (x,y)
windField = createWindField();

%% Plots 2D contour plot of wind energy
% Second argument sets 3D if high. Last is mesh fineness for plotting.
meFPlot = 0.05; 
is3D = 0;
plotWindfield(windField,is3D,meFPlot);

if (is3D == 0)
    hold on

    %% Demonstrate greedy policy (show position of UAV)
    % Value function is energy from wind field
    % Demonstrate how to plot simulation
    % Demonstrate how plane can move and make decisions autonomously
    nSteps = 100;
    startPos = [0.8 1];
    stepSize = 0.1;

    % Describe how value function is discretized
    % sideLength must be even (how far away airplane can see in mesh units / 2)
    % meF refers to mesh fineness
    meFVFun = 0.05; sideLength = 8; % Ex
    travelUpEnergy(nSteps, stepSize, windField,startPos, meFVFun, sideLength);
    
    title('Path of UAV in Windfield');
    
    %% Display training data for neural network
    % Given (x,y,z,windValue) tells best direction to go
    % Generate this by using the gradient based method in travelUpEnergy
    % trainData
    
    % Define the points at which we provide training data
    xBoundsTrain = [-1.5 2];
    yBoundsTrain = [-1.5 2];
    trainDataFineness = 0.5;
    xValsTrain = xBoundsTrain(1):trainDataFineness:xBoundsTrain(2);
    yValsTrain = yBoundsTrain(1):trainDataFineness:yBoundsTrain(2);
    
    % Create training data at each of these specified points
    trainData = zeros(length(xValsTrain), length(yValsTrain));
    
    % Keep track of where we are in the grid
    whic
    for trainX =  xValsTrain
        
        for trainY = yValsTrain            
            
            % Define start position and step size
            currPosTrain = [trainX trainY];
            arrSizeTrain = 0.2;            
               
            % Find ideal next position
            gridSideSize = sideLength*meFVFun; 
            nearE = getLocalValue(windField, meFVFun, gridSideSize, currPosTrain);
            nextPosTrain  = greedyPolicy(nearE, meFVFun, currPosTrain, arrSizeTrain);
            
            % Snap to nearest compass direction
            
            % Create arrows of the right length in the compass directions
            nDirections = 4; % number of distinc compass directions
            angles = 0:(2*pi/nDirections):2*pi;
            xRef = arrSizeTrain*cos(angles);
            yRef = arrSizeTrain*sin(angles);
            refArrow = [xRef', yRef'];            
            refArrow = refArrow(1:end-1,:);
            
            % Find closest compass direction arrow to ideal travel arrow
            origArrow = nextPosTrain - currPosTrain;
            distFromCompass = refArrow * origArrow';
            [~, bestArrowIndex] = max(distFromCompass);
            bestArrow = refArrow(bestArrowIndex,:);           
            
            % Append just calculated arrow to training data
            bestArrowIndex = trainData(currPosTrain(1), currPosTrain(2));
            
            % Display current arrow in training data
            dispArrow(currPosTrain, currPosTrain + bestArrow);
        end
    end

     
    
    % Neural neta:
    % Inputs: (x,y,z,windValue)
    % Outputs: value of going in 8 compass directions 
    
end



end

